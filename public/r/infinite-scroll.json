{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "infinite-scroll",
  "type": "registry:ui",
  "title": "Infinite Scroll",
  "files": [
    {
      "path": "src/components/extensions/infinite-scroll.tsx",
      "content": "\"use client\";\nimport * as React from \"react\";\n\ninterface InfiniteScrollProps {\n\tisLoading: boolean;\n\thasMore: boolean;\n\tnext: () => unknown;\n\tthreshold?: number;\n\troot?: Element | Document | null;\n\trootMargin?: string;\n\treverse?: boolean;\n\tchildren?: React.ReactNode;\n}\n\nexport default function InfiniteScroll({\n\tisLoading,\n\thasMore,\n\tnext,\n\tthreshold = 1,\n\troot = null,\n\trootMargin = \"0px\",\n\treverse,\n\tchildren,\n}: InfiniteScrollProps) {\n\tconst observer = React.useRef<IntersectionObserver>(null);\n\t// This callback ref will be called when it is dispatched to an element or detached from an element,\n\t// or when the callback function changes.\n\tconst observerRef = React.useCallback(\n\t\t(element: HTMLElement | null) => {\n\t\t\tlet safeThreshold = threshold;\n\t\t\tif (threshold < 0 || threshold > 1) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t\"threshold should be between 0 and 1. You are exceed the range. will use default value: 1\",\n\t\t\t\t);\n\t\t\t\tsafeThreshold = 1;\n\t\t\t}\n\t\t\t// When isLoading is true, this callback will do nothing.\n\t\t\t// It means that the next function will never be called.\n\t\t\t// It is safe because the intersection observer has disconnected the previous element.\n\t\t\tif (isLoading) return;\n\n\t\t\tif (observer.current) observer.current.disconnect();\n\t\t\tif (!element) return;\n\n\t\t\t// Create a new IntersectionObserver instance because hasMore or next may be changed.\n\t\t\tobserver.current = new IntersectionObserver(\n\t\t\t\t(entries) => {\n\t\t\t\t\tif (entries[0].isIntersecting && hasMore) {\n\t\t\t\t\t\tnext();\n\t\t\t\t\t\tconsole.log(\"next function called\");\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{ threshold: safeThreshold, root, rootMargin },\n\t\t\t);\n\t\t\tobserver.current.observe(element);\n\t\t},\n\t\t[hasMore, isLoading, next, threshold, root, rootMargin],\n\t);\n\n\tconst flattenChildren = React.useMemo(\n\t\t() => React.Children.toArray(children),\n\t\t[children],\n\t);\n\n\treturn (\n\t\t<>\n\t\t\t{flattenChildren.map((child, index) => {\n\t\t\t\tif (!React.isValidElement(child)) {\n\t\t\t\t\tprocess.env.NODE_ENV === \"development\" &&\n\t\t\t\t\t\tconsole.warn(\"You should use a valid element with InfiniteScroll\");\n\t\t\t\t\treturn child;\n\t\t\t\t}\n\n\t\t\t\tconst isObserveTarget = reverse\n\t\t\t\t\t? index === 0\n\t\t\t\t\t: index === flattenChildren.length - 1;\n\t\t\t\tconst ref = isObserveTarget ? observerRef : null;\n\t\t\t\t// @ts-ignore ignore ref type\n\t\t\t\treturn React.cloneElement(child, { ref });\n\t\t\t})}\n\t\t</>\n\t);\n}\n",
      "type": "registry:ui"
    }
  ]
}