{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "profile-uploader",
  "type": "registry:ui",
  "title": "Profile Image Uploader",
  "dependencies": [
    "react-image-crop",
    "lucide-react"
  ],
  "registryDependencies": [
    "dialog",
    "button"
  ],
  "files": [
    {
      "path": "src/components/extensions/files-uploader/profile.tsx",
      "content": "\"use client\";\n\nimport { Button } from \"@/components/ui/button\";\nimport {\n\tDialog,\n\tDialogContent,\n\tDialogDescription,\n\tDialogFooter,\n\tDialogHeader,\n\tDialogTitle,\n} from \"@/components/ui/dialog\";\nimport { cn } from \"@/lib/utils\";\nimport { CircleUserRoundIcon, CropIcon, XIcon } from \"lucide-react\";\nimport { SyntheticEvent, useCallback, useRef, useState } from \"react\";\nimport ReactCrop, {\n\tcenterCrop,\n\tmakeAspectCrop,\n\ttype Crop,\n\ttype PixelCrop,\n} from \"react-image-crop\";\nimport { useFileUpload, type FileMetadata } from \"./use-file-upload\";\n\nimport \"react-image-crop/dist/ReactCrop.css\";\n\nexport interface ProfileFileUploaderProps {\n\t/**\n\t * Size of the avatar in rem, controls the button dimensions\n\t * @default 4\n\t */\n\tsize?: number;\n\t/**\n\t * Custom class name for the root element\n\t */\n\tclassName?: string;\n\n\t/**\n\t * Initial file to display\n\t */\n\tinitialFile?: FileMetadata;\n\t/**\n\t * Callback when file changes\n\t */\n\tonFileChange?: (file: File | null) => void;\n\t/**\n\t * Custom class name for the avatar button\n\t */\n\tbuttonClassName?: string;\n\n\t/**\n\t * Whether the avatar should be rounded or square\n\t * @default false\n\t */\n\trounded?: boolean;\n\n\t/**\n\t * Enable image cropping before finalizing the upload\n\t * @default false\n\t */\n\tenableCrop?: boolean;\n}\n\n// Helper function to center the crop\nfunction centerAspectCrop(\n\tmediaWidth: number,\n\tmediaHeight: number,\n\taspect: number,\n): Crop {\n\treturn centerCrop(\n\t\tmakeAspectCrop(\n\t\t\t{\n\t\t\t\tunit: \"%\",\n\t\t\t\twidth: 50,\n\t\t\t\theight: 50,\n\t\t\t},\n\t\t\taspect,\n\t\t\tmediaWidth,\n\t\t\tmediaHeight,\n\t\t),\n\t\tmediaWidth,\n\t\tmediaHeight,\n\t);\n}\n\nexport function ProfileFileUploader({\n\tsize = 4,\n\tclassName,\n\tinitialFile,\n\tonFileChange,\n\tbuttonClassName,\n\trounded = false,\n\tenableCrop = false,\n}: ProfileFileUploaderProps) {\n\tconst [\n\t\t{ files, isDragging },\n\t\t{\n\t\t\tremoveFile,\n\t\t\topenFileDialog,\n\t\t\tgetInputProps,\n\t\t\thandleDragEnter,\n\t\t\thandleDragLeave,\n\t\t\thandleDragOver,\n\t\t\thandleDrop,\n\t\t\taddFiles,\n\t\t},\n\t] = useFileUpload({\n\t\taccept: \"image/*\",\n\t\tinitialFiles: initialFile ? [initialFile] : [],\n\t\tonFilesChange: (files) => {\n\t\t\tif (!enableCrop) {\n\t\t\t\tonFileChange?.(files[0]?.file instanceof File ? files[0].file : null);\n\t\t\t}\n\t\t},\n\t});\n\n\t// State for handling temporary image for cropping\n\tconst [tempImage, setTempImage] = useState<File | null>(null);\n\tconst [tempImageUrl, setTempImageUrl] = useState<string | null>(null);\n\n\t// Crop related state\n\tconst [dialogOpen, setDialogOpen] = useState(false);\n\tconst [crop, setCrop] = useState<Crop>();\n\tconst [croppedImageUrl, setCroppedImageUrl] = useState<string>(\"\");\n\tconst imgRef = useRef<HTMLImageElement | null>(null);\n\n\tconst previewUrl = files[0]?.preview || null;\n\tconst sizeInRem = `${size}rem`;\n\tconst iconSizeInRem = `${size / 2}rem`;\n\n\t// Custom file handler to intercept files before adding them to useFileUpload\n\tconst handleFileIntercept = useCallback(\n\t\t(acceptedFiles: File[]) => {\n\t\t\tif (enableCrop && acceptedFiles.length > 0) {\n\t\t\t\t// Store the file temporarily\n\t\t\t\tconst file = acceptedFiles[0];\n\t\t\t\tsetTempImage(file);\n\n\t\t\t\t// Create a temporary URL for the image\n\t\t\t\tconst url = URL.createObjectURL(file);\n\t\t\t\tsetTempImageUrl(url);\n\n\t\t\t\t// Open the crop dialog\n\t\t\t\tsetDialogOpen(true);\n\n\t\t\t\t// Don't add the file to useFileUpload yet\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If cropping is disabled, add files normally\n\t\t\taddFiles(acceptedFiles);\n\t\t},\n\t\t[enableCrop, addFiles],\n\t);\n\n\t// Custom drag and drop handlers that call the interceptor\n\tconst customHandleDrop = useCallback(\n\t\t(e: React.DragEvent<HTMLButtonElement>) => {\n\t\t\thandleDrop(e);\n\n\t\t\t// Get the dropped files from the event\n\t\t\tconst droppedFiles = Array.from(e.dataTransfer.files);\n\t\t\tif (droppedFiles.length > 0 && enableCrop) {\n\t\t\t\t// Prevent default useFileUpload behavior by stopping event propagation\n\t\t\t\te.stopPropagation();\n\t\t\t\thandleFileIntercept(droppedFiles);\n\t\t\t}\n\t\t},\n\t\t[handleDrop, handleFileIntercept, enableCrop],\n\t);\n\n\t// Override the default file input to use our interceptor\n\tconst customFileInputProps = {\n\t\t...getInputProps(),\n\t\tonChange: (e: React.ChangeEvent<HTMLInputElement>) => {\n\t\t\tif (enableCrop && e.target.files && e.target.files.length > 0) {\n\t\t\t\t// Handle the selected files with our interceptor\n\t\t\t\tconst selectedFiles = Array.from(e.target.files);\n\t\t\t\thandleFileIntercept(selectedFiles);\n\n\t\t\t\t// Clear the input value to allow selecting the same file again\n\t\t\t\te.target.value = \"\";\n\t\t\t} else {\n\t\t\t\t// Use the default handler from useFileUpload\n\t\t\t\tgetInputProps().onChange?.(e);\n\t\t\t}\n\t\t},\n\t};\n\n\tfunction onImageLoad(e: SyntheticEvent<HTMLImageElement>) {\n\t\tconst { width, height } = e.currentTarget;\n\t\tsetCrop(centerAspectCrop(width, height, 1));\n\t}\n\n\tfunction onCropComplete(pixelCrop: PixelCrop) {\n\t\tif (imgRef.current && pixelCrop.width && pixelCrop.height) {\n\t\t\tconst croppedImageUrl = getCroppedImg(imgRef.current, pixelCrop);\n\t\t\tsetCroppedImageUrl(croppedImageUrl);\n\t\t}\n\t}\n\n\tfunction getCroppedImg(image: HTMLImageElement, crop: PixelCrop): string {\n\t\tconst canvas = document.createElement(\"canvas\");\n\t\tconst scaleX = image.naturalWidth / image.width;\n\t\tconst scaleY = image.naturalHeight / image.height;\n\n\t\tcanvas.width = crop.width * scaleX;\n\t\tcanvas.height = crop.height * scaleY;\n\n\t\tconst ctx = canvas.getContext(\"2d\");\n\n\t\tif (ctx) {\n\t\t\tctx.imageSmoothingEnabled = false;\n\n\t\t\tctx.drawImage(\n\t\t\t\timage,\n\t\t\t\tcrop.x * scaleX,\n\t\t\t\tcrop.y * scaleY,\n\t\t\t\tcrop.width * scaleX,\n\t\t\t\tcrop.height * scaleY,\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tcrop.width * scaleX,\n\t\t\t\tcrop.height * scaleY,\n\t\t\t);\n\t\t}\n\n\t\treturn canvas.toDataURL(\"image/png\", 1.0);\n\t}\n\n\tasync function handleApplyCrop() {\n\t\tif (croppedImageUrl && tempImage) {\n\t\t\ttry {\n\t\t\t\t// Convert the data URL to a Blob\n\t\t\t\tconst response = await fetch(croppedImageUrl);\n\t\t\t\tconst blob = await response.blob();\n\n\t\t\t\t// Create a new File from the Blob\n\t\t\t\tconst croppedFile = new File([blob], tempImage.name, {\n\t\t\t\t\ttype: \"image/png\",\n\t\t\t\t\tlastModified: new Date().getTime(),\n\t\t\t\t});\n\n\t\t\t\t// Add the cropped file to useFileUpload\n\t\t\t\taddFiles([croppedFile]);\n\n\t\t\t\t// Call onFileChange with the cropped file\n\t\t\t\tonFileChange?.(croppedFile);\n\n\t\t\t\t// Clean up temporary states\n\t\t\t\tsetTempImage(null);\n\t\t\t\tif (tempImageUrl) {\n\t\t\t\t\tURL.revokeObjectURL(tempImageUrl);\n\t\t\t\t\tsetTempImageUrl(null);\n\t\t\t\t}\n\t\t\t\tsetCroppedImageUrl(\"\");\n\n\t\t\t\t// Close the dialog\n\t\t\t\tsetDialogOpen(false);\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(\"Error applying crop:\", error);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction handleCancelCrop() {\n\t\t// Clean up temporary states\n\t\tsetTempImage(null);\n\t\tif (tempImageUrl) {\n\t\t\tURL.revokeObjectURL(tempImageUrl);\n\t\t\tsetTempImageUrl(null);\n\t\t}\n\t\tsetCroppedImageUrl(\"\");\n\t\tsetDialogOpen(false);\n\t}\n\n\treturn (\n\t\t<div className={cn(\"flex flex-col items-center gap-2\", className)}>\n\t\t\t<div className=\"inline-flex relative\">\n\t\t\t\t<Button\n\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\"relative shadow-none p-0 overflow-hidden\",\n\t\t\t\t\t\tbuttonClassName,\n\t\t\t\t\t\trounded && \"rounded-full border-dashed\",\n\t\t\t\t\t\tisDragging && \"border-primary border-dashed opacity-70\",\n\t\t\t\t\t)}\n\t\t\t\t\tstyle={{ width: sizeInRem, height: sizeInRem }}\n\t\t\t\t\tonClick={openFileDialog}\n\t\t\t\t\tonDragEnter={handleDragEnter}\n\t\t\t\t\tonDragOver={handleDragOver}\n\t\t\t\t\tonDragLeave={handleDragLeave}\n\t\t\t\t\tonDrop={customHandleDrop}\n\t\t\t\t\taria-label={previewUrl ? \"Change image\" : \"Upload image\"}\n\t\t\t\t>\n\t\t\t\t\t{previewUrl ? (\n\t\t\t\t\t\t<img\n\t\t\t\t\t\t\tclassName=\"size-full object-cover\"\n\t\t\t\t\t\t\tsrc={previewUrl}\n\t\t\t\t\t\t\talt=\"Preview of uploaded\"\n\t\t\t\t\t\t\twidth={size * 16}\n\t\t\t\t\t\t\theight={size * 16}\n\t\t\t\t\t\t/>\n\t\t\t\t\t) : (\n\t\t\t\t\t\t<div aria-hidden=\"true\">\n\t\t\t\t\t\t\t<CircleUserRoundIcon\n\t\t\t\t\t\t\t\tclassName=\"opacity-60\"\n\t\t\t\t\t\t\t\tstyle={{ width: iconSizeInRem, height: iconSizeInRem }}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t)}\n\t\t\t\t</Button>\n\t\t\t\t{previewUrl && (\n\t\t\t\t\t<Button\n\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\tremoveFile(files[0]?.id);\n\t\t\t\t\t\t\tonFileChange?.(null);\n\t\t\t\t\t\t}}\n\t\t\t\t\t\tsize=\"icon\"\n\t\t\t\t\t\tclassName=\"-top-2 -right-2 absolute shadow-none border-2 border-background focus-visible:border-background rounded-full size-6\"\n\t\t\t\t\t\taria-label=\"Remove image\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<XIcon className=\"size-3.5\" />\n\t\t\t\t\t</Button>\n\t\t\t\t)}\n\t\t\t\t<input\n\t\t\t\t\t{...customFileInputProps}\n\t\t\t\t\tclassName=\"sr-only\"\n\t\t\t\t\taria-label=\"Upload image file\"\n\t\t\t\t/>\n\t\t\t</div>\n\n\t\t\t{enableCrop && (\n\t\t\t\t<Dialog open={dialogOpen} onOpenChange={setDialogOpen}>\n\t\t\t\t\t<DialogContent className=\"gap-0 p-0\">\n\t\t\t\t\t\t<DialogHeader>\n\t\t\t\t\t\t\t<DialogTitle />\n\t\t\t\t\t\t\t<DialogDescription />\n\t\t\t\t\t\t</DialogHeader>\n\t\t\t\t\t\t<div className=\"p-6 size-full\">\n\t\t\t\t\t\t\t{tempImageUrl && (\n\t\t\t\t\t\t\t\t<ReactCrop\n\t\t\t\t\t\t\t\t\tcrop={crop}\n\t\t\t\t\t\t\t\t\tonChange={(_, percentCrop) => setCrop(percentCrop)}\n\t\t\t\t\t\t\t\t\tonComplete={(c) => onCropComplete(c)}\n\t\t\t\t\t\t\t\t\taspect={1}\n\t\t\t\t\t\t\t\t\tclassName=\"w-full\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<div className=\"size-full\">\n\t\t\t\t\t\t\t\t\t\t<img\n\t\t\t\t\t\t\t\t\t\t\tref={imgRef}\n\t\t\t\t\t\t\t\t\t\t\tclassName=\"size-full\"\n\t\t\t\t\t\t\t\t\t\t\talt=\"Image to crop\"\n\t\t\t\t\t\t\t\t\t\t\tsrc={tempImageUrl}\n\t\t\t\t\t\t\t\t\t\t\tonLoad={onImageLoad}\n\t\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</ReactCrop>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<DialogFooter className=\"justify-center p-6 pt-0\">\n\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\t\ttype=\"reset\"\n\t\t\t\t\t\t\t\tclassName=\"w-fit\"\n\t\t\t\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\t\t\t\tonClick={handleCancelCrop}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<XIcon className=\"mr-1.5 size-4\" />\n\t\t\t\t\t\t\t\tCancel\n\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\ttype=\"submit\"\n\t\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\t\tclassName=\"w-fit\"\n\t\t\t\t\t\t\t\tonClick={handleApplyCrop}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<CropIcon className=\"mr-1.5 size-4\" />\n\t\t\t\t\t\t\t\tCrop\n\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t</DialogFooter>\n\t\t\t\t\t</DialogContent>\n\t\t\t\t</Dialog>\n\t\t\t)}\n\t\t</div>\n\t);\n}\n\n// Export named component as default for backward compatibility\nexport default ProfileFileUploader;\n",
      "type": "registry:ui"
    },
    {
      "path": "src/components/extensions/files-uploader/use-file-upload.ts",
      "content": "\"use client\";\n\nimport type React from \"react\";\nimport {\n\ttype ChangeEvent,\n\ttype DragEvent,\n\ttype InputHTMLAttributes,\n\tuseCallback,\n\tuseRef,\n\tuseState,\n} from \"react\";\n\nexport type FileMetadata = {\n\tname: string;\n\tsize: number;\n\ttype: string;\n\turl: string;\n\tid: string;\n};\n\nexport type FileWithPreview = {\n\tfile: File | FileMetadata;\n\tid: string;\n\tpreview?: string;\n};\n\nexport type FileUploadOptions = {\n\tmaxFiles?: number; // Only used when multiple is true, defaults to Infinity\n\tmaxSize?: number; // in bytes\n\taccept?: string;\n\tmultiple?: boolean; // Defaults to false\n\tinitialFiles?: FileMetadata[];\n\tonFilesChange?: (files: FileWithPreview[]) => void; // Callback when files change\n\tonFilesAdded?: (addedFiles: FileWithPreview[]) => void; // Callback when new files are added\n};\n\nexport type FileUploadState = {\n\tfiles: FileWithPreview[];\n\tisDragging: boolean;\n\terrors: string[];\n};\n\nexport type FileUploadActions = {\n\taddFiles: (files: FileList | File[]) => void;\n\tremoveFile: (id: string) => void;\n\tclearFiles: () => void;\n\tclearErrors: () => void;\n\thandleDragEnter: (e: DragEvent<HTMLElement>) => void;\n\thandleDragLeave: (e: DragEvent<HTMLElement>) => void;\n\thandleDragOver: (e: DragEvent<HTMLElement>) => void;\n\thandleDrop: (e: DragEvent<HTMLElement>) => void;\n\thandleFileChange: (e: ChangeEvent<HTMLInputElement>) => void;\n\topenFileDialog: () => void;\n\tgetInputProps: (\n\t\tprops?: InputHTMLAttributes<HTMLInputElement>,\n\t) => InputHTMLAttributes<HTMLInputElement> & {\n\t\tref: React.Ref<HTMLInputElement>;\n\t};\n};\n\nexport const useFileUpload = (\n\toptions: FileUploadOptions = {},\n): [FileUploadState, FileUploadActions] => {\n\tconst {\n\t\tmaxFiles = Number.POSITIVE_INFINITY,\n\t\tmaxSize = Number.POSITIVE_INFINITY,\n\t\taccept = \"*\",\n\t\tmultiple = false,\n\t\tinitialFiles = [],\n\t\tonFilesChange,\n\t\tonFilesAdded,\n\t} = options;\n\n\tconst [state, setState] = useState<FileUploadState>({\n\t\tfiles: initialFiles.map((file) => ({\n\t\t\tfile,\n\t\t\tid: file.id,\n\t\t\tpreview: file.url,\n\t\t})),\n\t\tisDragging: false,\n\t\terrors: [],\n\t});\n\n\tconst inputRef = useRef<HTMLInputElement>(null);\n\n\tconst validateFile = useCallback(\n\t\t(file: File | FileMetadata): string | null => {\n\t\t\tif (file instanceof File) {\n\t\t\t\tif (file.size > maxSize) {\n\t\t\t\t\treturn `File \"${file.name}\" exceeds the maximum size of ${formatBytes(maxSize)}.`;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (file.size > maxSize) {\n\t\t\t\t\treturn `File \"${file.name}\" exceeds the maximum size of ${formatBytes(maxSize)}.`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (accept !== \"*\") {\n\t\t\t\tconst acceptedTypes = accept.split(\",\").map((type) => type.trim());\n\t\t\t\tconst fileType = file instanceof File ? file.type || \"\" : file.type;\n\t\t\t\tconst fileExtension = `.${file instanceof File ? file.name.split(\".\").pop() : file.name.split(\".\").pop()}`;\n\n\t\t\t\tconst isAccepted = acceptedTypes.some((type) => {\n\t\t\t\t\tif (type.startsWith(\".\")) {\n\t\t\t\t\t\treturn fileExtension.toLowerCase() === type.toLowerCase();\n\t\t\t\t\t}\n\t\t\t\t\tif (type.endsWith(\"/*\")) {\n\t\t\t\t\t\tconst baseType = type.split(\"/\")[0];\n\t\t\t\t\t\treturn fileType.startsWith(`${baseType}/`);\n\t\t\t\t\t}\n\t\t\t\t\treturn fileType === type;\n\t\t\t\t});\n\n\t\t\t\tif (!isAccepted) {\n\t\t\t\t\treturn `File \"${file instanceof File ? file.name : file.name}\" is not an accepted file type.`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t},\n\t\t[accept, maxSize],\n\t);\n\n\tconst createPreview = useCallback(\n\t\t(file: File | FileMetadata): string | undefined => {\n\t\t\tif (file instanceof File) {\n\t\t\t\treturn URL.createObjectURL(file);\n\t\t\t}\n\t\t\treturn file.url;\n\t\t},\n\t\t[],\n\t);\n\n\tconst generateUniqueId = useCallback((file: File | FileMetadata): string => {\n\t\tif (file instanceof File) {\n\t\t\treturn `${file.name}-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n\t\t}\n\t\treturn file.id;\n\t}, []);\n\n\tconst clearFiles = useCallback(() => {\n\t\tsetState((prev) => {\n\t\t\t// Clean up object URLs\n\t\t\tprev.files.forEach((file) => {\n\t\t\t\tif (\n\t\t\t\t\tfile.preview &&\n\t\t\t\t\tfile.file instanceof File &&\n\t\t\t\t\tfile.file.type.startsWith(\"image/\")\n\t\t\t\t) {\n\t\t\t\t\tURL.revokeObjectURL(file.preview);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (inputRef.current) {\n\t\t\t\tinputRef.current.value = \"\";\n\t\t\t}\n\n\t\t\tconst newState = {\n\t\t\t\t...prev,\n\t\t\t\tfiles: [],\n\t\t\t\terrors: [],\n\t\t\t};\n\n\t\t\tonFilesChange?.(newState.files);\n\t\t\treturn newState;\n\t\t});\n\t}, [onFilesChange]);\n\n\tconst addFiles = useCallback(\n\t\t(newFiles: FileList | File[]) => {\n\t\t\tif (!newFiles || newFiles.length === 0) return;\n\n\t\t\tconst newFilesArray = Array.from(newFiles);\n\t\t\tconst errors: string[] = [];\n\n\t\t\t// Clear existing errors when new files are uploaded\n\t\t\tsetState((prev) => ({ ...prev, errors: [] }));\n\n\t\t\t// In single file mode, clear existing files first\n\t\t\tif (!multiple) {\n\t\t\t\tclearFiles();\n\t\t\t}\n\n\t\t\t// Check if adding these files would exceed maxFiles (only in multiple mode)\n\t\t\tif (\n\t\t\t\tmultiple &&\n\t\t\t\tmaxFiles !== Number.POSITIVE_INFINITY &&\n\t\t\t\tstate.files.length + newFilesArray.length > maxFiles\n\t\t\t) {\n\t\t\t\terrors.push(`You can only upload a maximum of ${maxFiles} files.`);\n\t\t\t\tsetState((prev) => ({ ...prev, errors }));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst validFiles: FileWithPreview[] = [];\n\n\t\t\tnewFilesArray.forEach((file) => {\n\t\t\t\t// Check for duplicates\n\t\t\t\tconst isDuplicate = state.files.some(\n\t\t\t\t\t(existingFile) =>\n\t\t\t\t\t\texistingFile.file.name === file.name &&\n\t\t\t\t\t\texistingFile.file.size === file.size,\n\t\t\t\t);\n\n\t\t\t\t// Skip duplicate files silently\n\t\t\t\tif (isDuplicate) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Check file size\n\t\t\t\tif (file.size > maxSize) {\n\t\t\t\t\terrors.push(\n\t\t\t\t\t\tmultiple\n\t\t\t\t\t\t\t? `Some files exceed the maximum size of ${formatBytes(maxSize)}.`\n\t\t\t\t\t\t\t: `File exceeds the maximum size of ${formatBytes(maxSize)}.`,\n\t\t\t\t\t);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst error = validateFile(file);\n\t\t\t\tif (error) {\n\t\t\t\t\terrors.push(error);\n\t\t\t\t} else {\n\t\t\t\t\tvalidFiles.push({\n\t\t\t\t\t\tfile,\n\t\t\t\t\t\tid: generateUniqueId(file),\n\t\t\t\t\t\tpreview: createPreview(file),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Only update state if we have valid files to add\n\t\t\tif (validFiles.length > 0) {\n\t\t\t\t// Call the onFilesAdded callback with the newly added valid files\n\t\t\t\tonFilesAdded?.(validFiles);\n\n\t\t\t\tsetState((prev) => {\n\t\t\t\t\tconst newFiles = !multiple\n\t\t\t\t\t\t? validFiles\n\t\t\t\t\t\t: [...prev.files, ...validFiles];\n\t\t\t\t\tonFilesChange?.(newFiles);\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...prev,\n\t\t\t\t\t\tfiles: newFiles,\n\t\t\t\t\t\terrors,\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t} else if (errors.length > 0) {\n\t\t\t\tsetState((prev) => ({\n\t\t\t\t\t...prev,\n\t\t\t\t\terrors,\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\t// Reset input value after handling files\n\t\t\tif (inputRef.current) {\n\t\t\t\tinputRef.current.value = \"\";\n\t\t\t}\n\t\t},\n\t\t[\n\t\t\tstate.files.length,\n\t\t\tmaxFiles,\n\t\t\tmultiple,\n\t\t\tmaxSize,\n\t\t\tvalidateFile,\n\t\t\tcreatePreview,\n\t\t\tgenerateUniqueId,\n\t\t\tclearFiles,\n\t\t\tonFilesChange,\n\t\t\tonFilesAdded,\n\t\t],\n\t);\n\n\tconst removeFile = useCallback(\n\t\t(id: string) => {\n\t\t\tsetState((prev) => {\n\t\t\t\tconst fileToRemove = prev.files.find((file) => file.id === id);\n\t\t\t\tif (\n\t\t\t\t\tfileToRemove &&\n\t\t\t\t\tfileToRemove.preview &&\n\t\t\t\t\tfileToRemove.file instanceof File &&\n\t\t\t\t\tfileToRemove.file.type.startsWith(\"image/\")\n\t\t\t\t) {\n\t\t\t\t\tURL.revokeObjectURL(fileToRemove.preview);\n\t\t\t\t}\n\n\t\t\t\tconst newFiles = prev.files.filter((file) => file.id !== id);\n\t\t\t\tonFilesChange?.(newFiles);\n\n\t\t\t\treturn {\n\t\t\t\t\t...prev,\n\t\t\t\t\tfiles: newFiles,\n\t\t\t\t\terrors: [],\n\t\t\t\t};\n\t\t\t});\n\t\t},\n\t\t[onFilesChange],\n\t);\n\n\tconst clearErrors = useCallback(() => {\n\t\tsetState((prev) => ({\n\t\t\t...prev,\n\t\t\terrors: [],\n\t\t}));\n\t}, []);\n\n\tconst handleDragEnter = useCallback((e: DragEvent<HTMLElement>) => {\n\t\te.preventDefault();\n\t\te.stopPropagation();\n\t\tsetState((prev) => ({ ...prev, isDragging: true }));\n\t}, []);\n\n\tconst handleDragLeave = useCallback((e: DragEvent<HTMLElement>) => {\n\t\te.preventDefault();\n\t\te.stopPropagation();\n\n\t\tif (e.currentTarget.contains(e.relatedTarget as Node)) {\n\t\t\treturn;\n\t\t}\n\n\t\tsetState((prev) => ({ ...prev, isDragging: false }));\n\t}, []);\n\n\tconst handleDragOver = useCallback((e: DragEvent<HTMLElement>) => {\n\t\te.preventDefault();\n\t\te.stopPropagation();\n\t}, []);\n\n\tconst handleDrop = useCallback(\n\t\t(e: DragEvent<HTMLElement>) => {\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\tsetState((prev) => ({ ...prev, isDragging: false }));\n\n\t\t\t// Don't process files if the input is disabled\n\t\t\tif (inputRef.current?.disabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (e.dataTransfer.files && e.dataTransfer.files.length > 0) {\n\t\t\t\t// In single file mode, only use the first file\n\t\t\t\tif (!multiple) {\n\t\t\t\t\tconst file = e.dataTransfer.files[0];\n\t\t\t\t\taddFiles([file]);\n\t\t\t\t} else {\n\t\t\t\t\taddFiles(e.dataTransfer.files);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t[addFiles, multiple],\n\t);\n\n\tconst handleFileChange = useCallback(\n\t\t(e: ChangeEvent<HTMLInputElement>) => {\n\t\t\tif (e.target.files && e.target.files.length > 0) {\n\t\t\t\taddFiles(e.target.files);\n\t\t\t}\n\t\t},\n\t\t[addFiles],\n\t);\n\n\tconst openFileDialog = useCallback(() => {\n\t\tif (inputRef.current) {\n\t\t\tinputRef.current.click();\n\t\t}\n\t}, []);\n\n\tconst getInputProps = useCallback(\n\t\t(props: InputHTMLAttributes<HTMLInputElement> = {}) => {\n\t\t\treturn {\n\t\t\t\t...props,\n\t\t\t\ttype: \"file\" as const,\n\t\t\t\tonChange: handleFileChange,\n\t\t\t\taccept: props.accept || accept,\n\t\t\t\tmultiple: props.multiple !== undefined ? props.multiple : multiple,\n\t\t\t\tref: inputRef,\n\t\t\t};\n\t\t},\n\t\t[accept, multiple, handleFileChange],\n\t);\n\n\treturn [\n\t\tstate,\n\t\t{\n\t\t\taddFiles,\n\t\t\tremoveFile,\n\t\t\tclearFiles,\n\t\t\tclearErrors,\n\t\t\thandleDragEnter,\n\t\t\thandleDragLeave,\n\t\t\thandleDragOver,\n\t\t\thandleDrop,\n\t\t\thandleFileChange,\n\t\t\topenFileDialog,\n\t\t\tgetInputProps,\n\t\t},\n\t];\n};\n\n// Helper function to format bytes to human-readable format\nexport const formatBytes = (bytes: number, decimals = 2): string => {\n\tif (bytes === 0) return \"0 Bytes\";\n\n\tconst k = 1024;\n\tconst dm = decimals < 0 ? 0 : decimals;\n\tconst sizes = [\"Bytes\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"];\n\n\tconst i = Math.floor(Math.log(bytes) / Math.log(k));\n\n\treturn Number.parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + sizes[i];\n};\n",
      "type": "registry:file",
      "target": "src/components/extensions/files-uploader/use-file-upload.ts"
    }
  ]
}